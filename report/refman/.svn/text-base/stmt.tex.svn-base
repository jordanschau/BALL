\section{Statements}\label{Stmts}
At the top level, BALL is a sequence of statements. BALL statements
are further refined into three groups:

\begin{verbatim}
statement : function_definition
          | sim_function_definition
          | body_statement
          ;
\end{verbatim}

Body statements are statements that are allowed in the body of if
statements, functions, loops, and such. Function definitions must be
declared in the global scope. However, functions can only be called by
statements placed after they're defined. The same rule applies to
simfunctions.

Body statements, on the other hand, represents all statements that can
be placed in any scope inside a BALL program.

\begin{verbatim}
body_statement : if_statement
               | iteration_statement
               | jump_statement
               | declaration
               | stat_declaration
               | expression_statement
               | activate_statement
               | print_statement
               | assignment_statement
               ;
\end{verbatim}

\subsection{Function Definition}\label{FuncDef}
Function definitions are generated by the following grammar:

\begin{verbatim}
function_definition : 
        "function" identifier "(" parameter_list0 ")" "returns" type
                 ":" "end"
        "function" identifier "(" parameter_list0 ")" "returns" type
                 ":" body_statement_list "end"
                    ;
\end{verbatim}

Any statement starting with the \texttt{function} keyword is
immediately identified as a function definition. The return type of
the function is specified after the parameters, using the keyword
"returns". The function body can be empty. A function accepts a
comma-separated list of parameters specified by the grammar:

\begin{verbatim}
parameter_list0 :
                | parameter_list
                ;
parameter_list : parameter
               | parameter_list "," parameter
               ;
parameter : type identifier
          ;
\end{verbatim}

Parameter lists can be empty, meaning the function does not take any
arguments. An example function definition is as follows:

\begin{verbatim}
function iAddNumbers (number num1, number num2) returns number:
  return num1 + num2;
end
\end{verbatim}

\subsection{Simulation Function Definition}\label{ref_stmt_simdef}
Simulation function definitions require only a brief explanation since
they are in fact simpler to declare than regular functions:

\begin{verbatim}
sim_function_definition : "simfunction" identifier "is:"
        body_statement_list "end"
                        ;
\end{verbatim}

This grammar is very similar to function\_definition but differs in the
following ways: 

\begin{itemize}
\item
  simfunction definitions do not specify any parameters. The
  parameters are implicit: a simulation function only handles two
  \texttt{team} objects named \texttt{team1} and
  \texttt{team2}. \texttt{team1} and \texttt{team2} represent the two
  teams that the sim function is currently simulating for.
\item
  simfunction does not have an explicit return value. Again, this is
  because the return value is restricted to \texttt{team}.
\end{itemize}

\subsection{If Statements}

\begin{verbatim}
if_statement : 
        "if" "(" expression ")" "then:" body_statement_list "end"
        | "if" "(" expression ")" "then:" body_statement_list
                  else_statement "end"
        ;
\end{verbatim}

These are similar to Java if statements, but the delimiters are
\texttt{then:} and \texttt{end} instead of { and }.  expression should
be any boolean expression or other expression that resolves into a
boolean.

\subsection{Iteration Statements}

\begin{verbatim}
iteration_statement : "do:" body_statement_list "end"
                    | "do" expression "times:" body_statement_list
                            "end"
                    | "foreach" identifier "in" identifier ":"
                            body_statement_list "end"
                    ;
\end{verbatim}

The first and second lines produce do loops. A do loop simply loops a
specified amount of times. They 
come in two forms which can be illustrated by the following examples: 

\begin{verbatim}
number i = 1;
do:
  i *= 2;
  if (i >= 1024) then:
       stopdo;
   end
end
\end{verbatim}

This do loop is declared with \texttt{do:} and ends with
\texttt{end}. Everything in between will be repeated indefinitely or
until \texttt{stopdo;} is stated.

\begin{verbatim}
number i = 0;
do 5 times:
   i++
   print "looped" + i + "times!";
end
\end{verbatim}

This second do loop is performed exactly 5 times since that is the
number of loops specified. Note that the number of loops can be any
expression, and code such as \texttt{do num1+num2 times:} is
acceptable.  Finally, the third line of the grammar above produces
\texttt{foreach} statements. A \texttt{foreach} statement iterates
through a list and performs an action on each of the items in
sequence. A \texttt{foreach} statements may as well be halted with a
\texttt{stopdo;} statement. \texttt{foreach} loops are of the form:

\begin{verbatim}
print "The Mets roster is:";
foreach player in Mets's BATTERS:
   print player's name;
end
\end{verbatim}
 
 \subsection{Jump Statements}
The C Reference Manual describes jump statements with: `Jump
statements transfer control unconditionally.'' In BALL, we want to
prevent programmer mistakes by omitting some of such tools which many
programmers flag as ``bad practice.'' Hence, BALL only supports two
jump statements:

\begin{verbatim}
jump_statement : "stopdo" ";"
               | "return" expression ";"
               | "return" ";"
               ;
\end{verbatim}

A \texttt{stopdo;} statement may appear only in an iteration and
terminates the execution of the smallest enclosing such statement:
control passes to the statement following the newly terminated one.

\texttt{return} may only be used in functions. When invoked, the
function halts and returns to its caller. The function may return
nothing, as is the case with functions of return type \texttt{nothing}
(this also happens when letting the function flow off the end). Or the
function may return an expression with with type matching the
function's expected return type.

\subsection{Activate Statement} \label{ref_stmt_activate}
The activate statement is short, simple, and requires little explanation:

\begin{verbatim}
activate_statement : "activate" identifier ";"
                   ;
\end{verbatim}

\texttt{activate} is followed by an identifier, which should be the name of a
simulation function defined in the same BALL program. This statement
simply sets the simulation function as the \texttt{active} function for use
in the builtin function \texttt{sim}. For example:

\begin{verbatim}
activate mySimFunction;
sim(Astros, Mets, 3);
\end{verbatim}

This will return the winner of three games between the Astros and the
Mets using \texttt{mySimFunction} as simulation
function. \texttt{activate} may be called multiple times in the same
BALL program.

\subsection{Print Statement}

The print statement is very simple as well: 

\begin{verbatim}
print_statement : "print" expression ";"
                ;
\end{verbatim}

In a nutshell, \texttt{print} will print {\tt expression} if {\tt
  expression} resolves to a string or the string representation the
object that \texttt{expression} returns.

\begin{verbatim}
print player1's name + " is " + 5 + "th in the rankings!";
\end{verbatim}

The different objects are concatenated because arithmethic expressions
default to string concatenation if one of the operands is a
string. Each {\tt print} statement prints to a separate line.

\subsection{Assignment Statement}
Assignment statements are used to redefine the value of a
variable. The grammar for assignments is:

\begin{verbatim}
assignment_statement : identifier assignment_operator expression ";"
                     ;
assignment_operator : "=" | "+=" | "-=" | "*=" | "/=" | "%=" ;
\end{verbatim}

A typical variable assignment will be of the form:

\begin{verbatim}
number x = 10;
x = 11; // final value is 11
\end{verbatim}

Assignments can be made with more than just the "=" operator. The
operators "+=", "-=", "*=", "/=", "\%=" are shortcuts for:

\begin{verbatim}
i += num1; // i = i + num1;
i -= num1; // i = i - num1;
i *= num1; // i = i * num1;
i /= num1; // i = i / num1;
i %= num1; // i = i % num1;
\end{verbatim}
 
\subsection{Declaration Statements}

Declarations specify how BALL will set aside a new variable within the
scope of the declaration. Declarations have the form:

\begin{verbatim}
declaration : type variable_declarators ";"
            ;
variable_declarators : variable_declarator
                     | variable_declarators "," variable_declarator
                     ;
variable_declarator : identifier
                    | identifier "=" expression
                    ;
\end{verbatim}

\texttt{variable\_declarators} is a comma-separated parentheses
delimited list of declarators. Each declarator contains a name and
optionally an expression that initializes the variable's value. The
expression's type must match the type of the declaration statement.

\subsection{Type Specifiers}

The type specifiers in BALL are: 

\begin{verbatim}
type : "number" | "string"
     | "list"   | "team"
     | "player" | "nothing"
     | list_type
     ;

list_type : "list" "of" type
          ;
\end{verbatim}

List types are declared with the type of their contents.  The type
\texttt{nothing} is only used when specifying return values for
functions. For example:

\begin{verbatim}
function printHello (string helloString) returns nothing:
   print helloString;
end
\end{verbatim}

\subsection{Meaning of Declarations}

Declarations map an identifier to an expression. Since an expression
can produce any \texttt{atom\_expression} , this allows for
declarations such as \texttt{number someNumber=9;} and \texttt{string
  someString="Hello!";}. But expressions may produce other
combinations, and their return value will be mapped to the
identifier. In this example, \texttt{aTeam} will be mapped to the
return value of the load function: \texttt{team aTeam =
  load(myTeam.team);} Furthermore, identifiers could be mapped to the
return values of arithmetic expressions or list manipulations.

\subsection{Declaring Players and Teams}

As said before in section \ref{ref_data}, Players and teams cannot be
created inside a program. They must be loaded from a team file
formatted in CSV.

\subsection{Declaring a Stat}

Stats are small, portable functions that encapsulate just a single
expression that acts on a \texttt{player} or \texttt{team}
object. Whether the stat acts on a player or a team depends what stat
it calls to derive its value. Both \texttt{player} and \texttt{team}
objects have predefined stats. User-defined stats act on players if
the stats they call all act on players. The same goes for team
stats. However, if both player and team stats are called by a
user-defined stat, the compiler should fail to generate the
code. Similarly, if there are no stats called by a user-defined stat,
it should also fail because the use of the stat cannot be derived.


When defining a new stat, the user will need to build upon primitive
stats so BALL can derive what object the stat is for. For example:

\begin{verbatim}
stat ERA = ER/IP*9;
\end{verbatim}

This line of code defines a new stat for pitchers: the Earned Run
Average. A user may now access this 
stat from any pitcher just like he would access a primitive stat:
\texttt{player1's ERA}.

Stats return numbers. The user should be able to collect a stat as
a number at any time with code such as: 

\begin{verbatim}
number player1ERA = player1's ERA;
\end{verbatim}

\subsection{Scope}
All declarations made outside of functions, loops, or if-statements
are global. Functions themselves must also be global. However, the
scope of all declarations made inside of functions, loops, or if
statements ends at the end of the \texttt{body\_statement\_list}. The
end keyword marks the end of the deepest
\texttt{body\_statement\_list}.
